/*
 * grunt-requiregrep
 *
 * Copyright (c) 2013 Benjamin Eidelman
 * Licensed under the MIT license.
 */
'use strict';

module.exports = function(grunt) {
    'use strict';

    grunt.registerMultiTask('requiregrep', 'Creates AMD module with dependencies extracted from source files.', function() {

        // Merge task-specific and/or target-specific options with these defaults.
        var options = this.options({
            banner: '/* Generated by grunt-requiregrep.\n\nDependencies by file: <%= JSON.stringify(dependenciesByFile,null," ") %> */',
            requirePattern: /require\(\s*[\'\"]([^\'\"]*)[\'\"]/gim,
            onLoad: "    if (typeof window.console!='undefined'){window.console.log('all modules loaded');}"
        });

        this.files.forEach(function(f) {

            var dependencies = [];
            var dependenciesByFile = {};
            var moduleDef = [];

            f.src.forEach(function(src){
                var contents = grunt.file.read(src);
                var requirePattern = options.requirePattern;
                requirePattern.lastIndex = 0;
                var match = requirePattern.exec(contents);
                var registerDependency = function(dependencyName) {
                    var depByFile = (dependenciesByFile[src] = dependenciesByFile[src] || []);
                    if (depByFile.indexOf(dependencyName) < 0) {
                        depByFile.push(dependencyName);
                    }
                    if (dependencies.indexOf(dependencyName) < 0) {
                        dependencies.push(dependencyName);
                    }
                };
                while(match) {
                    var deps = match[1].replace(/[\s]+/g,'').split(',');
                    deps.forEach(registerDependency);
                    match = requirePattern.exec(contents);
                }
                if (options.forEachFile) {
                    options.forEachFile(src, contents, registerDependency);
                }
            });

            // Process banner.
            var banner = '';
            if (options.banner) {
                banner = grunt.template.process(options.banner, {
                    data: {
                        dependencies: dependencies,
                        dependenciesByFile: dependenciesByFile
                    }
                });
                moduleDef.push(banner+'\n');
            }

            var moduleName = options.moduleName || '';
            moduleDef.push("define(");
            if (moduleName) {
                moduleDef.push("'", moduleName, "',");
            }
            if (dependencies.length) {
                moduleDef.push("[");
                moduleDef.push(dependencies.map(function(name){
                    return "'"+name+"'";
                }).join(','));
                moduleDef.push("],");
            }
            moduleDef.push("function(){");
            if (options.onLoad) {
                moduleDef.push('\n',options.onLoad,'\n');
            }
            moduleDef.push("});");
            grunt.file.write(f.dest, moduleDef.join(''));
            grunt.log.writeln('Created module '+(moduleName||'<anonymous>')+' with dependencies: ' + dependencies);
            grunt.log.writeln("Saved " + f.dest);
        });
    });
};